<!DOCTYPE html>
<html lang="">
  <head>
    <meta charset="utf-8">
    <meta name="darkreader-lock">
    <title>/console</title>
    <style>
      * {
        scrollbar-width: none;
      }
      body {
        background-color: black;
        overflow: hidden;
        font-family: monospace;
        color: #ffa;
        text-align: center;
        font-size: xxx-large;
        touch-action: manipulation;
        user-select: none;
      }
      #bg {
        position: fixed;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        margin: auto;
        max-width: 100%;
        max-height: 100vh;
        z-index: -999;
        aspect-ratio: 4/3;
        filter: blur(0px);
      }
      #keyboard {
        position: fixed;
        bottom: 10px;
        left: 0;
        right: 0;
        margin: auto;
        width: 90%;
        height: max(30%,300px);
        display: grid;
        grid-template-columns: repeat(12, 1fr);
        border-style: solid;
        background-color: black;
      }
      #keyboardclose {
        position: absolute;
        top: -65px;
        right: 0;
        width: 50px;
        height: 50px;
        color: #f55;
        border-style: solid;
      }
      .keyboardkey {
        align-content: center;
        text-align: center;
        border-width: 1px;
      }
    </style>
  </head>
  <body>
    <canvas id="bg">Enable javascript to view this page</canvas>
    <img id="sheet" style="display: none" src="tileset.png"></img>
    <div id="keyboard" style="display: none">
      <a id="keyboardclose" onclick="keyboard.style.display='none'">X</a>
    </div>
  <script>
    const bg = document.getElementById("bg");
    const sheet = document.getElementById("sheet");
    const keyboard = document.getElementById("keyboard");
    const ctx = bg.getContext("2d");
    const rows = 34;
    const cols = 48;
    bg.width = 768+4;
    bg.height = 544+4;
    var prevt = 0;
    var screen = Array(rows*cols).fill(32);
    var variables = {};
    var curpos = 0;
    var curflicker = 0;
    var redraw = true;
    var need_kbinit = true;
    ctx.imageSmoothingEnabled = false;
    ctx.fillStyle = "#ffffaa";
    ctx.fillRect(0, 0, 772, 548);
    ctx.fillStyle = "#000000";
    ctx.fillRect(2, 2, 768, 544);
    // filesystem stuff
    const chunk = (rows-1) * cols
    var filetable = {};
    var program = {};
    var programcounter = -1;
    var running = false;
    var tap_holding = undefined;
    var prev_touch_x = -1;
    var prev_touch_y = -1;
    // screen redraw
    function frame(t) {
      var dt = t - prevt;
      if (redraw) {
        redraw = false;
        for (var y=0; y<rows; y++) {
          for (var x=0; x<cols; x++) {
            var symbol = screen[y*cols + x];
            ctx.drawImage(sheet, (symbol%16)*8, Math.floor(symbol/16)*8, 8, 8, x*16+2, y*16+2, 16, 16);
          }
        }
      }
      curflicker += dt;
      var x = curpos % cols;
      var y = Math.floor(curpos / cols);
      var symbol = screen[y*cols + x];
      var offset = (curflicker % 500 < 250) * 128
      ctx.drawImage(sheet, (symbol%16)*8+offset, Math.floor(symbol/16)*8, 8, 8, x*16+2, y*16+2, 16, 16);
      prevt = t;
      if (running) {
        var res = runcommand(program[programcounter]);
        if (res) {
          write(res, true);
        }
        var all_inds = Object.keys(program);
        var is_end = true;
        for (var i of all_inds) {
          if (i > programcounter) {
            programcounter = i;
            is_end = false;
            break;
          }
        }
        if (is_end) {
          write("READY", true);
          running = false;
        }
      }
      requestAnimationFrame(frame);
    }
    // console specific functions
    function getlineind(curpos) {
      return Math.floor(curpos / cols) * cols;
    }
    function write(text, newline) {
      redraw = true;
      if (typeof text === "number") {
        text = String.fromCharCode(text);
      }
      var did_newline = false;
      for (var i of text) {
        if (i == "\n") {
          curpos = getlineind(curpos) + cols;
        } else {
          screen[curpos] = i.charCodeAt(0);
          curpos += 1;
        }
        if (curpos >= rows*cols) {
          screen = screen.slice(cols).concat(Array(cols).fill(32));
          curpos -= cols;
          did_newline = true;
        }
      }
      if (!newline) {return}
      if (!did_newline) {curpos = getlineind(curpos) + cols}
      while (curpos >= rows*cols) {
          screen = screen.slice(cols).concat(Array(cols).fill(32));
          curpos -= cols;
      }
    }
    function writefile(name, data) {
      filetable[name] = data + " ".repeat(chunk - data.length);
    }
    function runcommand(cmd) {
      var args = [];
      var this_arg = "";
      // parsing arguments
      for (var i=0; i<cmd.length; i++) {
        if (", ".includes(cmd[i])) {
          if (this_arg) {
            args.push(this_arg);
          }
          this_arg = "";
          continue;
        }
        if (cmd[i] == '"') {
          if (this_arg) {
            args.push(this_arg);
          }
          this_arg = "";
          var leftover = cmd.slice(i+1);
          if (leftover.includes('"')) {
            i += leftover.indexOf('"') + 2;
            args.push(leftover.slice(0, leftover.indexOf('"')));
            continue;
          } else {
            running = false;
            return "UNTERMINATED STRING LITERAL";
          }
        }
        this_arg += cmd[i];
      }
      if (this_arg) {
        args.push(this_arg);
      }
      for (var i=0; i<args.length; i++) {
        if (args[i][0] == "$") {
          var this_var = variables[args[i].slice(1)];
          if (this_var != undefined) {
            args[i] = this_var;
          }
        }
      }
      // running the command
      switch (args[0].toUpperCase()) {
        case "PRINT":
          return args.slice(1).join(" ");
        case "ASSIGN":
          variables[args[1]] = args[2];
          return;
        case "WRITE":
          running = false;
          return "COMING SOON";
        case "LIST":
          var line_nums = Object.keys(program);
          var line_content = Object.values(program);
          return line_nums.map((num, ind) => num + " " + line_content[ind]).join("\n");
        case "NEW":
          program = {};
          return;
        case "RUN":
          if (running) {
            running = false;
            return "CANT RUN INSIDE PROGRAM";
          }
          programcounter = Object.keys(program)[0];
          running = true;
          return;
        case "DIR":
          return Object.keys(filetable).join("\n");
        case "CAT":
          if (!Object.keys(filetable).includes(args[1])) {
            running = false;
            return "FILE NOT FOUND";
          }
          return filetable[args[1]].trim();
        case "GOTO":
          if (args[1] && /^\d+$/.test(args[1])) {
            programcounter = args[1]-1; // chess battle advanced
          }
          return;
        default:
          running = false;
          return "UNKNOWN COMMAND " + args[0];
      }
    }
    function onkeypress(ev) {
      if (!ev.fake) {
        keyboard.style.display = "none";
        bg.style.marginTop = "";
        bg.style.width = "";
      }
      if (ev.ctrlKey) {return}
      curflicker = 0;
      redraw = true;
      switch (ev.keyCode) {
        case 8: // backspace
          if (curpos > 0) {
            curpos -= 1;
            screen[curpos] = 32;
          }
          break;
        case 9: // tab
          ev.preventDefault();
          if (running) {
            running = false;
            write("INTERRUPTED", true);
          }
          return;
        case 13: // enter
          ev.preventDefault();
          if (running) {
            return;
          }
          var line_ind = getlineind(curpos);
          var line = String.fromCharCode.apply(null, screen.slice(line_ind, line_ind + cols)).trim();
          write("", true);
          if (line != "") {
            var split_line = line.split(" ");
            if (/^\d+$/.test(split_line[0])) {
              var cmd = split_line.slice(1).join(" ");
              if (cmd) {
                program[split_line[0]] = cmd;
              } else {
                delete program[split_line[0]];
              }
              return;
            }
            var res = runcommand(line);
            if (res) {
              write(res, true);
            }
          }
          break;
        case 37: // left
          ev.preventDefault();
          if (curpos > 0 && !running) {
            curpos -= 1;
          }
          break;
        case 38: // up
          ev.preventDefault();
          if (curpos >= cols && !running) {
            curpos -= cols;
          }
          break;
        case 39: // right
          ev.preventDefault();
          if (curpos < rows*cols-1 && !running) {
            curpos += 1;
          }
          break;
        case 40: // down
          ev.preventDefault();
          if (curpos < cols * (rows-1) && !running) {
            curpos += cols;
          }
          break;
        default:
          if (ev.key.length == 1 && !running) {
            ev.preventDefault();
            var this_code = ev.key.toUpperCase().charCodeAt(0);
            if (this_code >= 256) {
              this_code = 0;
            }
            //console.log(ev.key, this_code);
            write(this_code, false);
          }
          break;
      }
    }
    function onmobiletap(ev) {
      if (ev.target == bg) {
        var touch = ev.touches[0];
        var rect = bg.getBoundingClientRect();
        var touch_x = (touch.pageX - rect.x) / rect.width * cols;
        touch_x = Math.floor(Math.min(Math.max(touch_x, 0), cols-1));
        var touch_y = (touch.pageY - rect.y) / rect.height * rows;
        touch_y = Math.floor(Math.min(Math.max(touch_y, 0), rows-1));
        curpos = touch_x + touch_y * cols;
        curflicker = 0;
        redraw = true;
      }
      tap_holding = ev.target;
      if (tap_holding && tap_holding.className == "keyboardkey" && tap_holding.textContent != " ") {
        tap_holding.style.backgroundColor = "#221";
      }
      prev_touch_x = ev.touches[0].clientX;
      prev_touch_y = ev.touches[0].clientY;
      keyboard.style.display = "";
      if (window.innerWidth > window.innerHeight) {
        // horizontal
        bg.style.marginTop = "";
        bg.style.width = "";
      } else {
        // vertical
        bg.style.marginTop = "50%";
        bg.style.width = "100%";
      }
      if (need_kbinit) {
        need_kbinit = false;
        for (var i of "T!#$%^`*_+\"B1234567890-=qwertyuiop[]asdfghjkl;'Rzxcvbnm,./ S") {
          var b = document.createElement("a");
          if (i == "T") {i = "HLT";}
          if (i == "B") {i = "BACK";}
          if (i == "R") {i = "RET";}
          if (i == "S") {i = "SPACE";}
          b.textContent = i;
          b.className = "keyboardkey";
          keyboard.appendChild(b);
        }
      }
    }
    function onmobilerelease(ev) {
      if (tap_holding) {
        tap_holding.style.backgroundColor = "";
      }
      if (Math.abs(ev.changedTouches[0].clientX - prev_touch_x) > 20 ||
          Math.abs(ev.changedTouches[0].clientY - prev_touch_y) > 20) {
        return
      }
      var text = ev.target.textContent;
      if (text && ev.target.className == "keyboardkey") {
        switch(text) {
          case "HLT":
            onkeypress({keyCode: 9, preventDefault: () => {}, fake: true});
            break;
          case "BACK":
            onkeypress({keyCode: 8, preventDefault: () => {}, fake: true});
            break;
          case "RET":
            onkeypress({keyCode: 13, preventDefault: () => {}, fake: true});
            break;
          case "SPACE":
            text = " ";
          default:
            onkeypress({key: text, keyCode: text.charCodeAt(0), preventDefault: () => {}, fake: true});
            break;
        }
      }
    }
    addEventListener("keydown", onkeypress);
    addEventListener("touchstart", onmobiletap);
    addEventListener("touchend", onmobilerelease);
    // silly temp
    var temp_text = '\n10 ASSIGN H "HELLO,"\n20 ASSIGN W "WORLD!"\n30 PRINT $H $W\nRUN';
    write(temp_text, true);
    curpos = cols;
    writefile("HI", "HELLO FAKE-BASIC!!");
    // entering the loop
    requestAnimationFrame(frame);
  </script>
  </body>
</html>
